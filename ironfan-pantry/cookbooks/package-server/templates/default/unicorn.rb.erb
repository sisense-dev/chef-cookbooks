# Generated by Chef
#
# See http://unicorn.bogomips.org/Unicorn/Configurator.html for complete documentation

app_dir         = '<%= node[:package_server][:gem][:home_dir] %>'
worker_processes  <%= node[:package_server][:gem][:workers] %>
working_directory app_dir

# Load app into the master before forking workers for super-fast worker spawn times
preload_app       true

# Nuke workers after 60 seconds (the default)
timeout           60

# Listen on a Unix domain socket
listen            '<%= node[:package_server][:gem][:tmp_dir] %>/unicorn.socket'

# Process Management
pid               '<%= node[:package_server][:pid_dir] %>/unicorn.pid'
stderr_path       '<%= node[:package_server][:gem][:log_dir] %>/unicorn.stderr.log'
stdout_path       '<%= node[:package_server][:gem][:log_dir] %>/unicorn.stdout.log'

# http://www.rubyenterpriseedition.com/faq.html#adapt_apps_for_cow
GC.copy_on_write_friendly = true if GC.respond_to?(:copy_on_write_friendly=)

before_fork do |server, worker|

  ##
  # When sent a USR2, Unicorn will suffix its pidfile with .oldbin and
  # immediately start loading up a new version of itself (loaded with a new
  # version of our app). When this new Unicorn is completely loaded
  # it will begin spawning workers. The first worker spawned will check to
  # see if an .oldbin pidfile exists. If so, this means we've just booted up
  # a new Unicorn and need to tell the old one that it can now die. To do so
  # we send it a QUIT.
  #
  # Using this method we get 0 downtime deploys.

  old_pid = "#{server.config[:pid]}.oldbin"

  if File.exists?(old_pid) && server.pid != old_pid
    begin
      sig = (worker.nr + 1) >= server.worker_processes ? :QUIT : :TTOU
      Process.kill(sig, File.read(old_pid).to_i)
    rescue Errno::ENOENT, Errno::ESRCH
      # someone else did our job for us
    end
  end
end
