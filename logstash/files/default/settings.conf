input {
  redis {
    host => "127.0.0.1"
    port => 6379
    data_type => "list"
    key => "logstash"
    codec => json
  }


 file {
    path => "/var/log/redis_6379.log"
    type => redisLog
    start_position => "beginning"

  }
 		
}

filter {
  if ([type] == "redisLog") {
        if([message] =~ /WARNING/) {
            grok{
		match => ["message", "WARNING"]
                add_field => { "RedisLogType" => "WARNING" } 
               }
	    
         }
         else if([message] =~ /ERROR/) {
            grok{
		match => ["message", "ERROR"]
                add_field => { "RedisLogType" => "ERROR" } 
               }
	    
         }
         else {
	     drop { }
    
          }    
   }
 
  
}

filter {
	if "productLogs" in [type] {	
		grok {
			match => ["duration", "%{NUMBER:duration:float}"]
			overwrite => ["duration"]	
		}		
		
		grok {
			match => ["queryResponeLengthBytes", "%{INT:queryResponeLengthBytes:int}"]
			overwrite => ["queryResponeLengthBytes"]	
		}

		grok {
			match => ["EC_DBFarmSizeBytes", "%{INT:EC_DBFarmSizeBytes:int}"]
			overwrite => ["EC_DBFarmSizeBytes"]	
		}		

		grok {
			match => ["concurrentQuery", "%{INT:concurrentQuery:int}"]
			overwrite => ["concurrentQuery"]	
		}	

		grok {
			match => ["concurrentBuild", "%{INT:concurrentBuild:int}"]
			overwrite => ["concurrentBuild"]	
		}
		grok {
			match => ["columnsCount", "%{INT:columnsCount:int}"]
			overwrite => ["columnsCount"]	
		}

		grok {
			match => ["RowsAfterFetch", "%{INT:RowsAfterFetch:int}"]
			overwrite => ["RowsAfterFetch"]	
		}			
		
		mutate {
				remove_tag => [ "_grokparsefailure" ]	 
			}	
	}
}

output {
  elasticsearch {
        host => "localhost"                                                                                                                                                                                                                                                    
        protocol => "http"} 
}
